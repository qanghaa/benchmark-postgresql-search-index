// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

type BulkInsertLogsParams struct {
	UserID    pgtype.UUID        `json:"user_id"`
	Domain    string             `json:"domain"`
	Action    string             `json:"action"`
	Content   []byte             `json:"content"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
}

const countLogs = `-- name: CountLogs :one
SELECT COUNT(*) FROM logs
`

func (q *Queries) CountLogs(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countLogs)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countLogsPartial = `-- name: CountLogsPartial :one
SELECT COUNT(*) FROM logs
WHERE 
    ($1::uuid IS NULL OR user_id = $1) AND
    ($2::text IS NULL OR domain = $2) AND
    ($3::timestamptz IS NULL OR created_at >= $3) AND
    ($4::timestamptz IS NULL OR created_at <= $4) AND
    content::text ILIKE '%' || $5::text || '%'
`

type CountLogsPartialParams struct {
	UserID        pgtype.UUID        `json:"user_id"`
	Domain        pgtype.Text        `json:"domain"`
	CreatedAtFrom pgtype.Timestamptz `json:"created_at_from"`
	CreatedAtTo   pgtype.Timestamptz `json:"created_at_to"`
	SearchTerm    pgtype.Text        `json:"search_term"`
}

func (q *Queries) CountLogsPartial(ctx context.Context, arg CountLogsPartialParams) (int64, error) {
	row := q.db.QueryRow(ctx, countLogsPartial,
		arg.UserID,
		arg.Domain,
		arg.CreatedAtFrom,
		arg.CreatedAtTo,
		arg.SearchTerm,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countLogsWithFilters = `-- name: CountLogsWithFilters :one
SELECT COUNT(*) FROM logs
WHERE 
    ($1::uuid IS NULL OR user_id = $1) AND
    ($2::text IS NULL OR domain = $2) AND
    ($3::timestamptz IS NULL OR created_at >= $3) AND
    ($4::timestamptz IS NULL OR created_at <= $4) AND
    ($5::text IS NULL OR to_tsvector('english', content::text) @@ plainto_tsquery('english', $5))
`

type CountLogsWithFiltersParams struct {
	UserID        pgtype.UUID        `json:"user_id"`
	Domain        pgtype.Text        `json:"domain"`
	CreatedAtFrom pgtype.Timestamptz `json:"created_at_from"`
	CreatedAtTo   pgtype.Timestamptz `json:"created_at_to"`
	ContentSearch pgtype.Text        `json:"content_search"`
}

func (q *Queries) CountLogsWithFilters(ctx context.Context, arg CountLogsWithFiltersParams) (int64, error) {
	row := q.db.QueryRow(ctx, countLogsWithFilters,
		arg.UserID,
		arg.Domain,
		arg.CreatedAtFrom,
		arg.CreatedAtTo,
		arg.ContentSearch,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createLog = `-- name: CreateLog :one
INSERT INTO logs (user_id, domain, action, content, created_at)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, user_id, domain, action, content, created_at
`

type CreateLogParams struct {
	UserID    pgtype.UUID        `json:"user_id"`
	Domain    string             `json:"domain"`
	Action    string             `json:"action"`
	Content   []byte             `json:"content"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) CreateLog(ctx context.Context, arg CreateLogParams) (Log, error) {
	row := q.db.QueryRow(ctx, createLog,
		arg.UserID,
		arg.Domain,
		arg.Action,
		arg.Content,
		arg.CreatedAt,
	)
	var i Log
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Domain,
		&i.Action,
		&i.Content,
		&i.CreatedAt,
	)
	return i, err
}

const deleteLog = `-- name: DeleteLog :exec
DELETE FROM logs WHERE id = $1
`

func (q *Queries) DeleteLog(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteLog, id)
	return err
}

const getLog = `-- name: GetLog :one
SELECT id, user_id, domain, action, content, created_at
FROM logs
WHERE id = $1
`

func (q *Queries) GetLog(ctx context.Context, id pgtype.UUID) (Log, error) {
	row := q.db.QueryRow(ctx, getLog, id)
	var i Log
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Domain,
		&i.Action,
		&i.Content,
		&i.CreatedAt,
	)
	return i, err
}

const listLogs = `-- name: ListLogs :many
SELECT id, user_id, domain, action, content, created_at
FROM logs
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListLogsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListLogs(ctx context.Context, arg ListLogsParams) ([]Log, error) {
	rows, err := q.db.Query(ctx, listLogs, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Log{}
	for rows.Next() {
		var i Log
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Domain,
			&i.Action,
			&i.Content,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLogsByDomain = `-- name: ListLogsByDomain :many
SELECT id, user_id, domain, action, content, created_at
FROM logs
WHERE domain = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListLogsByDomainParams struct {
	Domain string `json:"domain"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

func (q *Queries) ListLogsByDomain(ctx context.Context, arg ListLogsByDomainParams) ([]Log, error) {
	rows, err := q.db.Query(ctx, listLogsByDomain, arg.Domain, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Log{}
	for rows.Next() {
		var i Log
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Domain,
			&i.Action,
			&i.Content,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLogsByUserID = `-- name: ListLogsByUserID :many
SELECT id, user_id, domain, action, content, created_at
FROM logs
WHERE user_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListLogsByUserIDParams struct {
	UserID pgtype.UUID `json:"user_id"`
	Limit  int32       `json:"limit"`
	Offset int32       `json:"offset"`
}

func (q *Queries) ListLogsByUserID(ctx context.Context, arg ListLogsByUserIDParams) ([]Log, error) {
	rows, err := q.db.Query(ctx, listLogsByUserID, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Log{}
	for rows.Next() {
		var i Log
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Domain,
			&i.Action,
			&i.Content,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLogsWithFilters = `-- name: ListLogsWithFilters :many
SELECT id, user_id, domain, action, content, created_at
FROM logs
WHERE 
    ($3::uuid IS NULL OR user_id = $3) AND
    ($4::text IS NULL OR domain = $4) AND
    ($5::timestamptz IS NULL OR created_at >= $5) AND
    ($6::timestamptz IS NULL OR created_at <= $6) AND
    ($7::text IS NULL OR to_tsvector('english', content::text) @@ plainto_tsquery('english', $7))
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListLogsWithFiltersParams struct {
	Limit         int32              `json:"limit"`
	Offset        int32              `json:"offset"`
	UserID        pgtype.UUID        `json:"user_id"`
	Domain        pgtype.Text        `json:"domain"`
	CreatedAtFrom pgtype.Timestamptz `json:"created_at_from"`
	CreatedAtTo   pgtype.Timestamptz `json:"created_at_to"`
	ContentSearch pgtype.Text        `json:"content_search"`
}

func (q *Queries) ListLogsWithFilters(ctx context.Context, arg ListLogsWithFiltersParams) ([]Log, error) {
	rows, err := q.db.Query(ctx, listLogsWithFilters,
		arg.Limit,
		arg.Offset,
		arg.UserID,
		arg.Domain,
		arg.CreatedAtFrom,
		arg.CreatedAtTo,
		arg.ContentSearch,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Log{}
	for rows.Next() {
		var i Log
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Domain,
			&i.Action,
			&i.Content,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchLogsPartial = `-- name: SearchLogsPartial :many
SELECT id, user_id, domain, action, content, created_at
FROM logs
WHERE 
    ($1::uuid IS NULL OR user_id = $1) AND
    ($2::text IS NULL OR domain = $2) AND
    ($3::timestamptz IS NULL OR created_at >= $3) AND
    ($4::timestamptz IS NULL OR created_at <= $4) AND
    content::text ILIKE '%' || $5::text || '%'
ORDER BY created_at DESC
LIMIT $7 OFFSET $6
`

type SearchLogsPartialParams struct {
	UserID        pgtype.UUID        `json:"user_id"`
	Domain        pgtype.Text        `json:"domain"`
	CreatedAtFrom pgtype.Timestamptz `json:"created_at_from"`
	CreatedAtTo   pgtype.Timestamptz `json:"created_at_to"`
	SearchTerm    pgtype.Text        `json:"search_term"`
	Offset        pgtype.Int4        `json:"offset"`
	Limit         pgtype.Int4        `json:"limit"`
}

func (q *Queries) SearchLogsPartial(ctx context.Context, arg SearchLogsPartialParams) ([]Log, error) {
	rows, err := q.db.Query(ctx, searchLogsPartial,
		arg.UserID,
		arg.Domain,
		arg.CreatedAtFrom,
		arg.CreatedAtTo,
		arg.SearchTerm,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Log{}
	for rows.Next() {
		var i Log
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Domain,
			&i.Action,
			&i.Content,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const truncateLogs = `-- name: TruncateLogs :exec
TRUNCATE TABLE logs RESTART IDENTITY CASCADE
`

func (q *Queries) TruncateLogs(ctx context.Context) error {
	_, err := q.db.Exec(ctx, truncateLogs)
	return err
}
